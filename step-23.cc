
/* ---------------------------------------------------------------------
 *
 * Copyright (C) 2006 - 2015 by the deal.II authors
 *
 * This file is part of the deal.II library.
 *
 * The deal.II library is free software; you can use it, redistribute
 * it, and/or modify it under the terms of the GNU Lesser General
 * Public License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * The full text of the license can be found in the file LICENSE at
 * the top level of the deal.II distribution.
 *
 * ---------------------------------------------------------------------
 *
 *
 * Author: Wolfgang Bangerth, Texas A&M University, 2006
 */


// @sect3{Include files}

// We start with the usual assortment of include files that we've seen in so
// many of the previous tests:
#include <deal.II/base/quadrature_lib.h>
#include <deal.II/base/function.h>
#include <deal.II/base/logstream.h>
#include <deal.II/lac/sparse_direct.h>

#include <deal.II/lac/vector.h>
#include <deal.II/lac/full_matrix.h>
#include <deal.II/lac/sparse_matrix.h>
#include <deal.II/lac/dynamic_sparsity_pattern.h>
#include <deal.II/lac/solver_cg.h>
#include <deal.II/lac/precondition.h>
#include <deal.II/lac/constraint_matrix.h>

#include <deal.II/grid/tria.h>
#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/tria_accessor.h>
#include <deal.II/grid/tria_iterator.h>

#include <deal.II/dofs/dof_handler.h>
#include <deal.II/dofs/dof_accessor.h>
#include <deal.II/dofs/dof_tools.h>

#include <deal.II/fe/fe_q.h>
#include <deal.II/fe/fe_system.h>
#include <deal.II/fe/fe_values.h>

#include <deal.II/numerics/data_out.h>

#include <fstream>
#include <iostream>

// Here are the only three include files of some new interest: The first one
// is already used, for example, for the
// VectorTools::interpolate_boundary_values and
// MatrixTools::apply_boundary_values functions. However, we here use another
// function in that class, VectorTools::project to compute our initial values
// as the $L^2$ projection of the continuous initial values. Furthermore, we
// use VectorTools::create_right_hand_side to generate the integrals
// $(f^n,\phi^n_i)$. These were previously always generated by hand in
// <code>assemble_system</code> or similar functions in application
// code. However, we're too lazy to do that here, so simply use a library
// function:
#include <deal.II/numerics/vector_tools.h>

// In a very similar vein, we are also too lazy to write the code to assemble
// mass and Laplace matrices, although it would have only taken copying the
// relevant code from any number of previous tutorial programs. Rather, we
// want to focus on the things that are truly new to this program and
// therefore use the MatrixCreator::create_mass_matrix and
// MatrixCreator::create_laplace_matrix functions. They are declared here:
#include <deal.II/numerics/matrix_tools.h>

// Finally, here is an include file that contains all sorts of tool functions
// that one sometimes needs. In particular, we need the
// Utilities::int_to_string class that, given an integer argument, returns a
// string representation of it. It is particularly useful since it allows for
// a second parameter indicating the number of digits to which we want the
// result padded with leading zeros. We will use this to write output files
// that have the form <code>solution-XXX.gnuplot</code> where <code>XXX</code>
// denotes the number of the time step and always consists of three digits
// even if we are still in the single or double digit time steps.
#include <deal.II/base/utilities.h>

#include "include/RightHandSide.h"
#include "include/LinearElasticity.h"

#define BOOST_TEST_MODULE SolidMechanicsTest
#include <boost/test/included/unit_test.hpp>

// @sect3{The <code>main</code> function}

// What remains is the main function of the program. There is nothing here
// that hasn't been shown in several of the previous programs:

BOOST_AUTO_TEST_CASE( polynomial_degree_test )
{
    using namespace dealii;
    using namespace Step23;

    deallog.depth_console( 0 );

    double time_step = 2.5e-3;
    double theta = 1;
    unsigned int degree = 1;
    unsigned int n_global_refines = 1;
    double gravity = 2;
    double distributed_load = 0;

    unsigned int nbComputations = 4;

    std::vector<unsigned int> n_dofs( nbComputations );
    std::vector<double> solution( nbComputations );

    for ( unsigned int i = 0; i < nbComputations; ++i )
    {
        n_global_refines = i + 2;
        WaveEquation<2> wave_equation_solver( time_step, theta, degree, gravity, distributed_load, n_global_refines );
        wave_equation_solver.run();

        n_dofs[i] = wave_equation_solver.n_dofs();
        solution[i] = wave_equation_solver.point_value();

        BOOST_CHECK_CLOSE( solution[i], -0.001351993, 0.1 );
    }

    std::vector<double> error( nbComputations - 1 );

    for ( unsigned int i = 0; i < error.size(); ++i )
        error[i] = std::abs( solution[i] - solution[nbComputations - 1] ) / std::abs( solution[nbComputations - 1] );

    for ( unsigned int i = 0; i < error.size() - 1; ++i )
    {
        double rate = 2 * std::log10( error[i] / error[i + 1] );
        rate /= std::log10( n_dofs[i + 1] / n_dofs[i] );

        BOOST_CHECK_GE( rate, 1.9 );
    }
}

BOOST_AUTO_TEST_CASE( polynomial_degree_test_distributed_load )
{
    using namespace dealii;
    using namespace Step23;

    deallog.depth_console( 0 );

    double time_step = 2.5e-3;
    double theta = 1;
    unsigned int degree = 1;
    unsigned int n_global_refines = 1;
    double gravity = 0;
    double distributed_load = 49.757;

    unsigned int nbComputations = 4;

    std::vector<unsigned int> n_dofs( nbComputations );
    std::vector<double> solution( nbComputations );

    for ( unsigned int i = 0; i < nbComputations; ++i )
    {
        n_global_refines = i + 2;
        WaveEquation<2> wave_equation_solver( time_step, theta, degree, gravity, distributed_load, n_global_refines );
        wave_equation_solver.run();

        n_dofs[i] = wave_equation_solver.n_dofs();
        solution[i] = wave_equation_solver.point_value();

        BOOST_CHECK_CLOSE( solution[i], -0.0016910513, 0.1 );
    }

    std::vector<double> error( nbComputations - 1 );

    for ( unsigned int i = 0; i < error.size(); ++i )
        error[i] = std::abs( solution[i] - solution[nbComputations - 1] ) / std::abs( solution[nbComputations - 1] );

    for ( unsigned int i = 0; i < error.size() - 1; ++i )
    {
        double rate = 2 * std::log10( error[i] / error[i + 1] );
        rate /= std::log10( n_dofs[i + 1] / n_dofs[i] );

        BOOST_CHECK_GE( rate, 1.9 );
    }
}

BOOST_AUTO_TEST_CASE( crank_nicolson_distributed_load )
{
    using namespace dealii;
    using namespace Step23;

    deallog.depth_console( 0 );

    double time_step = 2.5e-3;
    double theta = 0.5;
    unsigned int degree = 1;
    unsigned int n_global_refines = 2;
    double gravity = 0;
    double distributed_load = 49.757;

    unsigned int nbComputations = 4;

    std::vector<unsigned int> nbTimeSteps( nbComputations );
    std::vector<double> solution_l2_norm( nbComputations );

    for ( unsigned int i = 0; i < nbComputations; ++i )
    {
        double dt = time_step / std::pow( 2, i );

        WaveEquation<2> wave_equation_solver( dt, theta, degree, gravity, distributed_load, n_global_refines );
        wave_equation_solver.run();

        if ( i > 0 )
            assert( nbTimeSteps[i - 1] * 2 == wave_equation_solver.timestep_number );

        double l2norm = 0;

        for ( unsigned int i = 0; i < wave_equation_solver.solution_v.size(); ++i )
            l2norm += wave_equation_solver.solution_v[i] * wave_equation_solver.solution_v[i];

        l2norm = std::sqrt( l2norm );

        solution_l2_norm[i] = l2norm;
        nbTimeSteps[i] = wave_equation_solver.timestep_number;
    }

    std::vector<double> error( nbComputations - 1 );

    for ( unsigned int i = 0; i < solution_l2_norm.size(); ++i )
        std::cout << "l2norm = " << solution_l2_norm[i] << std::endl;

    for ( unsigned int i = 0; i < error.size(); ++i )
    {
        error[i] = std::abs( solution_l2_norm[i] - solution_l2_norm[nbComputations - 1] ) / std::abs( solution_l2_norm[nbComputations - 1] );

        std::cout << "error = " << error[i] << std::endl;
    }

    std::vector<double> order( nbComputations - 2 );

    for ( unsigned int i = 0; i < order.size(); ++i )
    {
        double dti = time_step / std::pow( 2, i );
        double dtinew = time_step / std::pow( 2, i + 1 );
        order[i] = std::log10( error[i + 1] ) - std::log10( error[i] );
        order[i] /= std::log10( dtinew ) - std::log10( dti );
        std::cout << "order = " << order[i] << std::endl;

        BOOST_CHECK_GE( order[i], 2 );
    }
}

BOOST_AUTO_TEST_CASE( crank_nicolson_combined_load )
{
    using namespace dealii;
    using namespace Step23;

    deallog.depth_console( 0 );

    double time_step = 2.5e-3;
    double theta = 0.5;
    unsigned int degree = 1;
    unsigned int n_global_refines = 2;
    double gravity = 2;
    double distributed_load = 49.757;

    unsigned int nbComputations = 4;

    std::vector<unsigned int> nbTimeSteps( nbComputations );
    std::vector<double> solution_l2_norm( nbComputations );

    for ( unsigned int i = 0; i < nbComputations; ++i )
    {
        double dt = time_step / std::pow( 2, i );

        WaveEquation<2> wave_equation_solver( dt, theta, degree, gravity, distributed_load, n_global_refines );
        wave_equation_solver.run();

        if ( i > 0 )
            assert( nbTimeSteps[i - 1] * 2 == wave_equation_solver.timestep_number );

        double l2norm = 0;

        for ( unsigned int i = 0; i < wave_equation_solver.solution_v.size(); ++i )
            l2norm += wave_equation_solver.solution_v[i] * wave_equation_solver.solution_v[i];

        l2norm = std::sqrt( l2norm );

        solution_l2_norm[i] = l2norm;
        nbTimeSteps[i] = wave_equation_solver.timestep_number;
    }

    std::vector<double> error( nbComputations - 1 );

    for ( unsigned int i = 0; i < solution_l2_norm.size(); ++i )
        std::cout << "l2norm = " << solution_l2_norm[i] << std::endl;

    for ( unsigned int i = 0; i < error.size(); ++i )
    {
        error[i] = std::abs( solution_l2_norm[i] - solution_l2_norm[nbComputations - 1] ) / std::abs( solution_l2_norm[nbComputations - 1] );

        std::cout << "error = " << error[i] << std::endl;
    }

    std::vector<double> order( nbComputations - 2 );

    for ( unsigned int i = 0; i < order.size(); ++i )
    {
        double dti = time_step / std::pow( 2, i );
        double dtinew = time_step / std::pow( 2, i + 1 );
        order[i] = std::log10( error[i + 1] ) - std::log10( error[i] );
        order[i] /= std::log10( dtinew ) - std::log10( dti );
        std::cout << "order = " << order[i] << std::endl;

        BOOST_CHECK_GE( order[i], 2 );
    }
}

BOOST_AUTO_TEST_CASE( crank_nicolson_test )
{
    using namespace dealii;
    using namespace Step23;

    deallog.depth_console( 0 );

    double time_step = 2.5e-3;
    double theta = 0.5;
    unsigned int degree = 1;
    unsigned int n_global_refines = 2;
    double gravity = 2;
    double distributed_load = 0;

    unsigned int nbComputations = 4;

    std::vector<unsigned int> nbTimeSteps( nbComputations );
    std::vector<double> solution_l2_norm( nbComputations );

    for ( unsigned int i = 0; i < nbComputations; ++i )
    {
        double dt = time_step / std::pow( 2, i );

        WaveEquation<2> wave_equation_solver( dt, theta, degree, gravity, distributed_load, n_global_refines );
        wave_equation_solver.run();

        if ( i > 0 )
            assert( nbTimeSteps[i - 1] * 2 == wave_equation_solver.timestep_number );

        double l2norm = 0;

        for ( unsigned int i = 0; i < wave_equation_solver.solution_v.size(); ++i )
            l2norm += wave_equation_solver.solution_v[i] * wave_equation_solver.solution_v[i];

        l2norm = std::sqrt( l2norm );

        solution_l2_norm[i] = l2norm;
        nbTimeSteps[i] = wave_equation_solver.timestep_number;
    }

    std::vector<double> error( nbComputations - 1 );

    for ( unsigned int i = 0; i < solution_l2_norm.size(); ++i )
        std::cout << "l2norm = " << solution_l2_norm[i] << std::endl;

    for ( unsigned int i = 0; i < error.size(); ++i )
    {
        error[i] = std::abs( solution_l2_norm[i] - solution_l2_norm[nbComputations - 1] ) / std::abs( solution_l2_norm[nbComputations - 1] );

        std::cout << "error = " << error[i] << std::endl;
    }

    std::vector<double> order( nbComputations - 2 );

    for ( unsigned int i = 0; i < order.size(); ++i )
    {
        double dti = time_step / std::pow( 2, i );
        double dtinew = time_step / std::pow( 2, i + 1 );
        order[i] = std::log10( error[i + 1] ) - std::log10( error[i] );
        order[i] /= std::log10( dtinew ) - std::log10( dti );
        std::cout << "order = " << order[i] << std::endl;

        BOOST_CHECK_GE( order[i], 2 );
    }
}

BOOST_AUTO_TEST_CASE( backward_euler )
{
    using namespace dealii;
    using namespace Step23;

    deallog.depth_console( 0 );

    double time_step = 2.5e-3;
    double theta = 1;
    unsigned int degree = 1;
    unsigned int n_global_refines = 2;
    double gravity = 2;
    double distributed_load = 0;

    unsigned int nbComputations = 4;

    std::vector<unsigned int> nbTimeSteps( nbComputations );
    std::vector<double> solution_l2_norm( nbComputations );

    for ( unsigned int i = 0; i < nbComputations; ++i )
    {
        double dt = time_step / std::pow( 2, i );

        WaveEquation<2> wave_equation_solver( dt, theta, degree, gravity, distributed_load, n_global_refines );
        wave_equation_solver.run();

        if ( i > 0 )
            assert( nbTimeSteps[i - 1] * 2 == wave_equation_solver.timestep_number );

        double l2norm = 0;

        for ( unsigned int i = 0; i < wave_equation_solver.solution_v.size(); ++i )
            l2norm += wave_equation_solver.solution_v[i] * wave_equation_solver.solution_v[i];

        l2norm = std::sqrt( l2norm );

        solution_l2_norm[i] = l2norm;
        nbTimeSteps[i] = wave_equation_solver.timestep_number;
    }

    std::vector<double> error( nbComputations - 1 );

    for ( unsigned int i = 0; i < error.size(); ++i )
    {
        error[i] = std::abs( solution_l2_norm[i] - solution_l2_norm[nbComputations - 1] ) / std::abs( solution_l2_norm[nbComputations - 1] );
        std::cout << "error = " << error[i] << std::endl;
    }

    std::vector<double> order( nbComputations - 2 );

    for ( unsigned int i = 0; i < order.size(); ++i )
    {
        double dti = time_step / std::pow( 2, i );
        double dtinew = time_step / std::pow( 2, i + 1 );
        order[i] = std::log10( error[i + 1] ) - std::log10( error[i] );
        order[i] /= std::log10( dtinew ) - std::log10( dti );

        std::cout << "order = " << order[i] << std::endl;

        BOOST_CHECK_GE( order[i], 1 );
    }
}

BOOST_AUTO_TEST_CASE( theta )
{
    using namespace dealii;
    using namespace Step23;

    deallog.depth_console( 0 );

    double time_step = 2.5e-3;
    double theta = 0.6;
    unsigned int degree = 1;
    unsigned int n_global_refines = 2;
    double gravity = 2;
    double distributed_load = 0;

    unsigned int nbComputations = 4;

    std::vector<unsigned int> nbTimeSteps( nbComputations );
    std::vector<double> solution_l2_norm( nbComputations );

    for ( unsigned int i = 0; i < nbComputations; ++i )
    {
        double dt = time_step / std::pow( 2, i );

        WaveEquation<2> wave_equation_solver( dt, theta, degree, gravity, distributed_load, n_global_refines );
        wave_equation_solver.run();

        if ( i > 0 )
            assert( nbTimeSteps[i - 1] * 2 == wave_equation_solver.timestep_number );

        double l2norm = 0;

        for ( unsigned int i = 0; i < wave_equation_solver.solution_v.size(); ++i )
            l2norm += wave_equation_solver.solution_v[i] * wave_equation_solver.solution_v[i];

        l2norm = std::sqrt( l2norm );

        solution_l2_norm[i] = l2norm;
        nbTimeSteps[i] = wave_equation_solver.timestep_number;
    }

    std::vector<double> error( nbComputations - 1 );

    for ( unsigned int i = 0; i < error.size(); ++i )
        error[i] = std::abs( solution_l2_norm[i] - solution_l2_norm[nbComputations - 1] ) / std::abs( solution_l2_norm[nbComputations - 1] );

    std::vector<double> order( nbComputations - 2 );

    for ( unsigned int i = 0; i < order.size(); ++i )
    {
        double dti = time_step / std::pow( 2, i );
        double dtinew = time_step / std::pow( 2, i + 1 );
        order[i] = std::log10( error[i + 1] ) - std::log10( error[i] );
        order[i] /= std::log10( dtinew ) - std::log10( dti );

        BOOST_CHECK_GE( order[i], 1 );
    }
}
